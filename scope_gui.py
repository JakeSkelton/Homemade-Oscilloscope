# -*- coding: utf-8 -*-
'''
Created on Fri Jul 24 13:11:36 2020

@author: jakes
'''

import os
import sys
import time
import signal
import multiprocessing as multi
import scope_base as base
import numpy as np
import tkinter as tk
from tkinter import ttk
import matplotlib
from matplotlib.backend_bases import (MouseButton, MouseEvent, KeyEvent, LocationEvent, PickEvent)
from functools import partial
from ctypes import windll

windll.shcore.SetProcessDpiAwareness(1) ### Fix dpi scaling when launching from cmd
try: matplotlib.use('TkAgg', force=True)
except ImportError: matplotlib.use('TkAgg', force=True)
matplotlib.rcParams['font.family'] = 'monospace'
matplotlib.rcParams['font.size'] = 10.0

starttime = time.time()

### Function declarations ###
class marker:
    """
    A class to wrap the markers generated by clicking in the plot window.
    """
    global canvas, ax
    global mode
    
    def __init__(self, sym, size=8, textloc=(0.5, 1.02), event=MouseButton.LEFT, x=[], y=[]):
        """
        Parameters
        ----------
        sym : string
            plt.plot accepted marker symbol (e.g. '+').
        size : int, optional
            Marker size. The default is 8.
        textloc : tuple, optional
            The position of the marker's coordinate text (in axes coordinates).
            The default is (0.5, 1.02).
        event : matplotlib.backend_bases event, optional
            Consult matplotlib documentation for possible event designations.
            The default is MouseButton.LEFT.
        x : number or array, optional
            The initial x coordinate of the marker. The default is [].
        y : number or array, optional
            The initial y coordinate of the marker. The default is [].

        Returns
        -------
        None.

        """
        self.symbol = sym
        self.event=event
        self.mark, = ax.plot(x, y, c='w', ls='', marker=self.symbol, markersize=size)
        if x and y:
            locstring = sym + "(%s, %s)"%(base.secformat(x, units=[' ms', ' ms', ' Hz'][mode]), 
                                          base.secformat(y, units=[' V', ' V', ' dB'][mode]))
        else:
            locstring = ''
        self.loclabel = ax.text(textloc[0], textloc[1], locstring, horizontalalignment='center',
                                verticalalignment='center', transform=ax.transAxes)
        keyworddict = {MouseButton:'button_press_event',
                       KeyEvent:'key_press_event'}
        canvas.mpl_connect(keyworddict[type(event)], self.onclick)
    
    def setlocation(self, x, y):
        """
        Change both the position of the marker on screen, and the displayed coordinates. Takes two
        floats as inputs.
        """
        self.mark.set_data(x, y)
        self.loclabel.set_text(self.symbol + 
                               "(%s, %s)"%(base.secformat(x, units=[' ms', ' ms', ' Hz'][mode]),
                                           base.secformat(y, units=[' V', ' V', ' dB'][mode])))
        canvas.draw()
    
    def onclick(self, click):
        if click.button == self.event:
            self.setlocation(click.xdata, click.ydata)
    
    def hide(self):
        """
        Remove the marker and accompanying coordinates from the plot window.
        """
        self.mark.set_data([], [])
        self.loclabel.set_text('')        
    
def mutualex(button, neighbours):
    """ 
    A simple function to disable the button corresponding to argument 'button', and re-enable the
    neighbouring buttons - passed as 'neighbours'. Used to make clear which option has been 
    selected.
    """
    button.state(['disabled'])
    for neighbour in neighbours:
        neighbour.state(['!disabled'])
        
def changetrig(button):
    global trigbuttons
    global trigger
    
    mutualex(button, set(trigbuttons) - {button})
    trigger = ['', '+', '-'][trigbuttons.index(button)]
    
def changemode(button):
    global modebuttons
    global mode, lastmode
   
    lastmode = mode
    mutualex(button, set(modebuttons) - {button})
    mode = modebuttons.index(button)
    
def resetavg():
    global avgnum
    global plotlabels
    avgnum = 0
    plotlabels['resmsg'].set_text(plotlabels['resmsg'].get_text()[:23] + "  %3d avgs"%(avgnum))
    
def burn(wipe=False):
    global canvas, line, auxline
    if wipe:
        auxline.set_data(([], []))
        auxline.set_visible(False)
    else:
        auxline.set_data(line.get_data())
        auxline.set_visible(True)
    canvas.draw()
    
def startstop(COMaddress=None):
    """
    startstop begins the process of communication with the microcontroller front-end via the 
    sub-process 'harvester'. It also applies any changes made to scope settings (timebase, 
    trigger mode, etc.). If data collection and plotting is already taking place, then startstop
    will pause this; this is necessary to use the UI at full speed and to reliably tell the 
    front-end of new data acquisistion parameters.

    Parameters
    ----------
    COMaddress : String, optional
        Serial port address of the mictrocontroller. This should only be given at startup because
        the port remains open throughout program operation and, if startstop receives the default
        'None', it will import the global port address.

    Returns
    -------
    None.

    """
    global started, mode, lastmode
    global trigger, triglvl
    global dropdown_tbase
    global canvas, ax, line, auxline, plotlabels, markers
    global thisconn
    global averaging, avgnum
    
    if not started:
        tbase_ind = dropdown_tbase.current()
        tbase = base.baselist[tbase_ind]
        thresh = int(1024*float(triglvl.get()[:-1])//3.3)
        delt = base.chooserate(tbase, resolution=['normal', 'highest', 'higher'][mode])
        avgnum = 0
        
        print("Measurement interval =", delt, "us")
        N = int(10**4*tbase//delt)
        print("N =", N)
        if mode == 2:
            numpoints = N//2 + 1
            ax = base.freqaxis(ax, delt)
        else:
            numpoints = N
            ax = base.timeaxis(ax, tbase)
        plotlabels['loadmsg'].set_visible(True)
        plotlabels['resmsg'].set_text("%4d points  %6d S/s  %3d avgs"
                                      %(numpoints, 10**6//delt, avgnum))
        [marker.hide() for marker in markers]
        line.set_visible(False)
        auxline.set_visible(False)
        canvas.draw()
        while thisconn.poll(0.001):
            thisconn.recv()
        thisconn.send(("portmsg", COMaddress, delt, mode, trigger, thresh, N))
        succeeded = False
        T = time.time()
        while not succeeded:
            if thisconn.poll(0.1):
                msg = thisconn.recv()
                if type(msg) == str:
                    print(msg)
                    if msg == "Success": 
                        succeeded = True
            if time.time() - T > 15:
                raise RuntimeError("Communication with microcontroller failed")
        plotlabels["loadmsg"].set_visible(False)
        plotlabels["playpause"].set_text(chr(9658))
        if not 2 < (mode + 1)*(lastmode + 1) < 9:   #Wipe burn if changing modes 1->3, 2->3 
            auxline.set_visible(True)               #or the reverse of these
        else:
            burn(wipe=True)
        canvas.draw()
        lastmode = mode
        started = True
        if mode == 1:
            recandplotsingle()
        else:
            line.set_visible(True)
            recandplot()
    elif started:
        plotlabels["playpause"].set_text(chr(9632))
        canvas.draw()
        thisconn.send("RESET")
        started = False

def harvester(pipeconn):
    """
    The target function of the separate sub-process 'courier' run in a processor core distinct from
    the one running this main program. Harvester runs the 'mainloop' function of the
    oscilloscope_base module and ferries the data thus received back to the main program through
    'pipeconn'. The function also responds to special messages: 'RESET' and 'STOP', sent by the
    main program.

    Parameters
    ----------
    pipeconn : Multiprocessing pipe connection object.

    Returns
    -------
    None.
    """
    try:
        started = False
        base.fileprint("\nHarvester started at {}\n".format(time.asctime(time.localtime())))
        pipeconn.send("Separate process started")
        while True:
            if pipeconn.poll(timeout=0.01):
                msg = pipeconn.recv() 
                base.fileprint("Main process to subprocess: {}\n".format(msg))
                pipeconn.send(msg)
                if type(msg) == tuple and msg[0] == "portmsg":
                    addr, delt, mode, trigger, trigthresh, N = msg[1:]
                    data = np.vstack((np.arange(N), np.zeros(N, dtype=int)))
                    compare = base.trigfunc(trigger)
                    port = base.startcomms(addr, delt)
                    pipeconn.send("Success")
                    started = True
                elif msg == "RESET":
                    port.write(b'-6')
                    started = False
                    continue
                elif msg == "STOP":
                    base.finishup(port)
                    break
            if started:
                data = base.mainloop(port, trigthresh, compare, data, delt)
                if mode == 2:
                    pipeconn.send(base.spectrum(data*np.array([[1], [3.3/1024]])))
                else:
                    pipeconn.send(data*np.array([[10**-3], [3.3/1024]]))
                    
    except Exception as err:
        pipeconn.send(err)
        base.fileprint("Harvester encontered {}: {}\n".format(type(err), err))
            
def recandplot():
    """
    A function which runs in the main process and, every *1* ms, receives the voltage data from
    'harvester'. The function then updates the plot window and calls itself with a delay.

    Parameters
    ----------
    None.

    Returns
    -------
    None.
    """
    global root
    global started
    global canvas, ax, line
    global plotlabels
    global thisconn
    global averaging, avgnum
    
    if started:
        if thisconn.poll(0.01):
            toplot = thisconn.recv()
            if type(toplot) == np.ndarray:
                if averaging.get() and toplot.size//2 == line.get_data()[1].size:
                    toplot[1,:] = (toplot[1,:] + avgnum*line.get_data()[1])/(avgnum + 1)
                    avgnum += 1
                    plotlabels['resmsg'].set_text(plotlabels['resmsg'].get_text()[:23]
                                                  + "  %3d avgs"%(avgnum))
                line.set_data(toplot[0,:], toplot[1,:])
                canvas.draw()
        root.after(1, recandplot)
        
def recandplotsingle():
    """
    A function which runs in the main process and, every *1* ms, receives the voltage data from
    'harvester'. The function then updates the plot window and calls itself with a delay.

    Parameters
    ----------
    None.

    Returns
    -------
    None.
    """
    global root
    global started
    global canvas, ax, line
    global thisconn
    
    if started:
        if thisconn.poll(1):
            toplot = thisconn.recv()
            if type(toplot) == np.ndarray:
                line.set_data(toplot[0,:], toplot[1,:])
                line.set_visible(True)
                startstop()
            else:
                root.after(1, recandplotsingle)
        else:
            root.after(1, recandplotsingle)
            
def savedata():
    global mode
    global line
    x, y = line.get_data()
    choices = [('Comma-delimited file', '*.csv'), ('Text file', '*.txt')]
    file = tk.filedialog.asksaveasfile(filetypes=choices, initialfile='data.csv',
                                       defaultextension='.csv')
    if file:
        file.write("x (%s), y (%s)\n"%(['ms', 'ms', 'Hz'][mode], ['V', 'V', 'dB'][mode]))
        for i in range(x.size):
            file.write("%.4f, %.4f\n"%(x[i], y[i]))
        file.close()
    
def savefigure():
    global fig
    choices = [('PNG', '*.png'), ('JPEG', '*.jpg *.jpeg'), ('SVG', '.svg'), ('PDF', '.pdf')]
    file = tk.filedialog.asksaveasfile(filetypes=choices, initialfile='figure',
                                       defaultextension='.png')
    if file:
        fig.savefig(file.name)
        file.close()
    
def finishup(pipeconn, courier, root):
    """ 
    A simple clean-up function which stops the microcontroller harvesting data, terminates the
    sub-process 'courier', and closes the tk window (if it's open).                                                     
    """
    pipeconn.send("STOP")
    #time.sleep(1)
    try:
        root.destroy()
    except tk.TclError:
        pass
    #courier.terminate()
    #courier.join()
    sys.exit()
               
## GUI setup ###
root = tk.Tk()
root.title('Oscilloscope')

### Variables ###
aspectratio = np.array([11,5])
defaultpad = (10,5)
trigger = ''
triglvl = tk.StringVar(root)
inittbase = base.baselist[2]
basechoice = tk.StringVar(root, value=base.secformat(inittbase, units=' ms'))
averaging = tk.BooleanVar(root, value=False)

### Menu bar ###
menubar = tk.Menu(root, tearoff=0)
root.configure(menu=menubar)

menu_file = tk.Menu(menubar, tearoff=0)
menu_file.add_command(label="Save current data", command=savedata)
menu_file.add_command(label="Save figure", command=savefigure)

menu_display = tk.Menu(menubar, tearoff=0)
menu_ch1 = tk.Menu(menu_display, tearoff=0)
menu_display.add_cascade(menu=menu_ch1, label='CH1')
menu_ch1.add_command(label='Burn current waveform', command=burn)
menu_ch1.add_command(label='Clear burn', command=partial(burn, True))
menu_display.add_checkbutton(label="Successive averaging", variable=averaging, command=resetavg,
                             onvalue=True, offvalue=False)

menu_help = tk.Menu(menubar, tearoff=0)
menu_help.add_command(label="README", command=lambda:os.system('start README.txt'))

submenus = [menu_file, menu_display, menu_help]
for ind in range(len(submenus)):
    menubar.add_cascade(menu=submenus[ind], label=['File', 'Display', 'Help'][ind])
    
### Main sections ###
mainframe = ttk.Frame(root)
mainframe.grid(column=0, row=0, sticky='NSEW')
frame_plot = ttk.Frame(mainframe, relief='groove', padding=1)
frame_controls = ttk.Frame(mainframe, padding=0)
frame_mode = ttk.Frame(frame_controls, relief='groove', padding=defaultpad)
frame_tbase = ttk.Frame(frame_controls, relief='groove', padding=defaultpad)
frame_trig = ttk.Frame(frame_controls, relief='groove', padding=defaultpad)
frame_empty = ttk.Frame(frame_controls, relief='groove', padding=defaultpad)
subframes = [frame_plot, frame_controls, frame_mode, frame_tbase, frame_trig, frame_empty]

frame_plot.grid(column=0, row=0, sticky='NSEW')
frame_controls.grid(column=1, row=0, sticky='NSEW')
frame_mode.grid(column=0, row=0, columnspan=2, sticky='NEW')
frame_tbase.grid(column=0, row=1, sticky='NSEW')
frame_trig.grid(column=1, row=1, sticky='NSEW')
frame_empty.grid(column=0, row=2, columnspan=2, sticky='NSEW')

### Mode buttons ###
but_trig = ttk.Button(frame_mode, text='Trigger', state=['disabled'])
but_single = ttk.Button(frame_mode, text='Single')
but_spect = ttk.Button(frame_mode, text='Spectrum')
modebuttons = [but_trig, but_single, but_spect]

for button in modebuttons:
    i = modebuttons.index(button)
    button.grid(column=i, row=0, padx=2, sticky='NEW')
    button.configure(command = partial(changemode, button))    

### Channel 1 controls ###
label_tbase = ttk.Label(frame_tbase, text='Timebase')
dropdown_tbase = ttk.Combobox(frame_tbase, textvariable=basechoice, 
                              values=list(base.secformat(base.baselist, units=' ms')))
but_start = ttk.Button(frame_tbase, text='Start/Stop', command=startstop)

label_tbase.grid(column=0, row=0, sticky='N')
dropdown_tbase.grid(column=0, row=1, pady=10, sticky='NEW')
but_start.grid(column=0, row=2, sticky='NEW')

### Trigger Controls ###
label_trig = ttk.Label(frame_trig, text='Trigger')
label_triglvl = ttk.Label(frame_trig, text='Threshold')
but_trigoff = ttk.Button(frame_trig, text='Off', state=['disabled'])
but_trigrise = ttk.Button(frame_trig, text=('_/' + chr(175)))
but_trigfall = ttk.Button(frame_trig, text=(chr(175) + '\_'))
trigbuttons = [but_trigoff, but_trigrise, but_trigfall]
spin_triglvl = tk.Spinbox(frame_trig, textvariable=triglvl, 
                          values=[format("%01.1f V" %(0.1*i)) for i in range(34)])
triglvl.set('1.0 V')

label_trig.grid(column=0, row=0, columnspan=1, pady=(0,10), sticky='N')
label_triglvl.grid(column=0, row=4, pady=(10,0), sticky='N')
for button in trigbuttons:
    i = trigbuttons.index(button)
    button.grid(column=0, row=i+1, sticky='EW')
    button.configure(command = partial(changetrig, button))
spin_triglvl.grid(column=0, row=5, pady=10, sticky='EW')

### Plot pane ###
fig, ax = base.drawplot(inittbase, size=(6*aspectratio/aspectratio[1]))
canvas = matplotlib.backends.backend_tkagg.FigureCanvasTkAgg(fig, master=root)

labelbox = ax.add_patch(matplotlib.patches.Rectangle(xy=(0, 1), width=1, height=0.05,
                         edgecolor='w', fill=False, transform=ax.transAxes, clip_on=False))
loadmsg = ax.text(0.9, 1.02, 'Loading...', horizontalalignment='center',
                  verticalalignment='center', transform=ax.transAxes)
loadmsg.set_visible(False)
playpause = ax.text(0.98, 1.02, chr(9658), fontsize=12, fontname="Courier New", 
                    horizontalalignment='center', verticalalignment='center', transform=ax.transAxes)
resmsg = ax.text(0.01, 1.02, '', horizontalalignment='left', verticalalignment='center',
                 transform=ax.transAxes)
markers = [marker('+', 8, textloc=(0.4,1.02), event=MouseButton.LEFT),
           marker('x', 6, textloc=(0.6,1.02), event=MouseButton.RIGHT)]
plotlabels = {"labelbox":labelbox, "loadmsg":loadmsg, "playpause":playpause, "resmsg":resmsg}
line, = ax.plot(np.arange(500), np.zeros(500, dtype=int), c='#983a9e', lw=1)
auxline, = ax.plot([], [], lw=1, c='#dbb135', visible=False) #f0c546

canvas.get_tk_widget().grid(in_=frame_plot, column=0, row=0, sticky='NSEW')


### Weighting ###
root.rowconfigure(0, weight=aspectratio[0])
root.columnconfigure(0, weight=aspectratio[1])
for frame in [mainframe] + subframes:
    frame.columnconfigure('all', weight=aspectratio[0])
    frame.rowconfigure('all', weight=aspectratio[1])      
frame_controls.columnconfigure('all', uniform="controls")
frame_controls.rowconfigure((0, 1), weight=0)
frame_tbase.rowconfigure('all', weight=0)
frame_trig.rowconfigure('all', weight=0)

but_start.focus_set

if __name__ == '__main__':
    try:
        thisconn, thatconn = multi.Pipe(duplex=True)
        started = False
        mode, lastmode = 0, 0
        avgnum = 0
        
        courier = multi.Process(target=harvester, args=(thatconn,))
        courier.start()
        startstop(COMaddress="COM7")
        root.mainloop()
        finishup(thisconn, courier, root)
    except KeyboardInterrupt:
        finishup(thisconn, courier, root)
    except Exception as e:
        finishup(thisconn, courier, root)
        raise e
